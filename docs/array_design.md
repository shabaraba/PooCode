# 配列の設計提案

## 1. 配列の作成方法

### 1.1 基本的な配列リテラル
すでに実装されている基本的な配列リテラル構文を拡張します。

```
[1, 2, 3]  // 整数の配列
["a", "b", "c"]  // 文字列の配列
[true, false, true]  // 真偽値の配列
[1, "a", true]  // 混合型の配列
```

### 1.2 範囲指定による配列作成
新たに範囲指定による配列作成を実装します。

```
[1..5]  // [1, 2, 3, 4, 5] を生成
[5..1]  // [5, 4, 3, 2, 1] を生成（降順）
["a".."e"]  // ["a", "b", "c", "d", "e"] を生成（文字範囲）
```

実装方針:
1. パーサーで `[start..end]` 構文を認識する新しいノードタイプ `RangeExpression` を追加
2. 評価器で範囲に基づいて適切な配列を生成

## 2. 配列の高階関数

### 2.1 map関数
配列の各要素に関数を適用し、新しい配列を返します。関数内では`🍕`を使って配列の各要素にアクセスします。

```
// double関数を定義
let double = fn() { 🍕 * 2 };

// map関数で各要素に適用（括弧あり）
[1, 2, 3] |> map(double)  // [2, 4, 6] を返す

// map関数で各要素に適用（括弧なし）
[1, 2, 3] |> map double  // [2, 4, 6] を返す
```

### 2.2 filter関数
条件を満たす要素のみを含む新しい配列を返します。関数内では`🍕`を使って配列の各要素にアクセスします。

```
// 偶数を判定する関数
let isEven = fn() { 🍕 % 2 == 0 };

// filter関数で偶数のみを抽出（括弧あり）
[1, 2, 3, 4, 5] |> filter(isEven)  // [2, 4] を返す

// filter関数で偶数のみを抽出（括弧なし）
[1, 2, 3, 4, 5] |> filter isEven  // [2, 4] を返す
```

※将来的にはラムダ式（インラインの無名関数）もサポートする予定ですが、現在の実装では別に定義した関数を渡す形式のみとします。

## 3. インデックスアクセスと範囲アクセス

### 3.1 インデックスアクセス（既存の機能強化）
```
array[0]  // 最初の要素
array[-1]  // 最後の要素（負のインデックスをサポート）
```

### 3.2 範囲アクセス（新機能）
```
array[1..3]  // インデックス1から3までの要素を含む部分配列
array[..3]   // 最初から3までの要素
array[3..]   // 3から最後までの要素
```

## 4. 実装計画

### 4.1 パーサーの拡張
1. `RangeExpression` ノードの追加
2. 範囲アクセス表現の構文解析

### 4.2 評価器の拡張
1. `evalArrayLiteral` 関数の実装（または既存の実装の改良）
2. `evalIndexExpression` 関数の実装または強化
3. `evalRangeExpression` 関数の追加
4. 負のインデックスの対応

### 4.3 組み込み関数の実装
1. `map`, `filter` 関数の実装
2. 配列メソッドとしての実装方法の検討

## 5. エラーハンドリング
1. 範囲外アクセスの適切なエラーメッセージ
2. 型エラーの明確なメッセージ
3. 高階関数への無効な引数のチェック
