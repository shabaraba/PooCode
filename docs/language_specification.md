# uncode言語仕様書

## 1. 概要

uncode（アンコード）は、💩をテーマにした独自のプログラミング言語です。シンプルながらも強力な機能を持ち、特にパイプライン処理と条件付き関数定義に特徴があります。この言語は教育目的や趣味のプログラミングに適しています。

## 2. 基本構文

### 2.1 ファイル拡張子

uncodeのソースファイルは以下の拡張子を使用します：
- `.poo`
- `.💩`

### 2.2 変数と代入

uncodeでは、変数宣言は不要で、代入によって自動的に変数が作成されます。代入には `>>` 演算子を使用します。

```
42 >> answer  // answerという変数に42を代入
"hello" >> greeting  // greetingという変数に"hello"を代入
```

### 2.3 特殊変数

uncodeには2つの特殊変数があります：

- `🍕` (ピザ): 関数の入力パラメータを表します
- `💩` (プー): 関数の戻り値を表します

これらの特殊変数は関数内で使用され、データの流れを制御します。

### 2.4 パイプライン記法

uncodeの最も特徴的な構文はパイプライン記法 `|>` です。これにより、関数を連鎖させてデータを処理できます。

```
5 |> add 3 |> multiply 2  // (5 + 3) * 2 = 16
```

また、並列パイプ `|` を使用して条件分岐を表現できます。

```
condition |> eq true |> do_something
```

### 2.5 コメント

uncodeでは、`//` から行末までがコメントとして扱われます。

```
// これはコメントです
42 >> answer  // これも行末コメントです
```

## 3. データ型

uncodeでは以下の基本データ型をサポートしています：

### 3.1 基本型

- `int`: 整数型
- `float`: 浮動小数点型
- `bool`: 真偽値型（`true` または `false`）
- `str`: 文字列型
- `null`: null値

### 3.2 複合型

- `array`: 配列型（`[1, 2, 3]` のように表現）
- `hash`: ハッシュマップ型（`{key: value}` のように表現）
- `class`: クラス型
- `instance`: インスタンス型

### 3.3 Pooオブジェクト

uncodeのすべてのオブジェクトは「Poo」を継承しており、`💩`メンバを持ちます。このメンバには任意の値を格納でき、オブジェクトのデフォルト値として使用されます。

## 4. 関数

### 4.1 関数定義

関数は `def` キーワードを使用して定義します。

```
def add(a, b): int -> int {
    🍕 + b >> 💩
}
```

関数定義の構文：
```
def [クラス名.]関数名([パラメータ])[: 入力型 -> 戻り値型] {
    // 関数本体
}
```

### 4.2 条件付き関数定義

uncodeの特徴的な機能として、条件付き関数定義があります。これにより、同じ名前の関数でも条件によって異なる実装を提供できます。

```
def is_even() if 🍕 % 2 == 0: int -> str {
    "偶数です" >> 💩
}

def is_even(): int -> str {
    "奇数です" >> 💩
}
```

この例では、入力が偶数の場合は最初の関数が実行され、そうでない場合は2番目の関数が実行されます。

### 4.3 関数呼び出し

関数呼び出しは以下の形式で行います：

```
add(5, 3)  // 通常の呼び出し
5 |> add 3  // パイプライン記法での呼び出し
```

### 4.4 case文

uncodeでは、`case`文を使用して条件分岐を行うことができます。`case`文は関数ブロックのトップレベルでのみ使用可能で、`🍕`変数を評価対象とします。

```
def check_number(): int -> str {
    case 🍕 % 2 == 0:
        "偶数です" >> 💩
    case 🍕 % 2 != 0:
        "奇数です" >> 💩
}
```

この例では、`🍕`が偶数の場合は「偶数です」と表示され、奇数の場合は「奇数です」と表示されます。

## 5. クラスとオブジェクト指向

### 5.1 クラス定義

クラスは以下のように定義します：

```
class Person
    public name
    public age
    
    def init(name, age): null -> null {
        name >> 🍕's name
        age >> 🍕's age
        null >> 💩
    }
    
    def greet(): null -> str {
        "こんにちは、" + 🍕's name + "さん！" >> 💩
    }
```

### 5.2 インスタンス生成

クラスのインスタンスは以下のように生成します：

```
Person("田中", 30) |> init >> person
```

または、プロパティを直接指定することもできます：

```
Person(
    name: "田中",
    age: 30
) >> person
```

### 5.3 プロパティアクセス

オブジェクトのプロパティには以下の方法でアクセスできます：

```
person's name  // 's 記法でアクセス
person |> .greet  // メソッド呼び出し
```

## 6. 制御構造

### 6.1 条件分岐

uncodeでは、伝統的なif文の代わりに条件付き関数定義とパイプライン記法を組み合わせて条件分岐を表現します。

```
condition |> eq true |> do_something
condition |> eq false |> do_something_else
```

### 6.2 ループ

ループは条件式と再帰を組み合わせて表現します：

```
{
    // ループ本体
    condition
} |> eq true |> repeat
```

## 7. 標準ライブラリ

uncodeには以下の標準関数が組み込まれています：

### 7.1 入出力

- `print`: 値を標準出力に表示
- `input`: ユーザーからの入力を取得

### 7.2 型変換

- `to_string`: 値を文字列に変換
- `to_int`: 値を整数に変換
- `to_float`: 値を浮動小数点数に変換
- `to_bool`: 値を真偽値に変換

### 7.3 数学関数

- `add`: 加算
- `sub`: 減算
- `mul`: 乗算
- `div`: 除算
- `mod`: 剰余

### 7.4 論理演算

- `eq`: 等価比較
- `ne`: 非等価比較
- `lt`: 未満比較
- `le`: 以下比較
- `gt`: 超過比較
- `ge`: 以上比較
- `and`: 論理積
- `or`: 論理和
- `not`: 論理否定

### 7.5 配列操作

- `len`: 配列の長さを取得
- `get`: 配列の要素を取得
- `set`: 配列の要素を設定
- `add`: 配列に要素を追加
- `each`: 配列の各要素に関数を適用

## 8. エラーハンドリング

uncodeでは、エラーは特殊なエラーオブジェクトとして表現されます。エラーハンドリングは以下のように行います：

```
operation |> is_error |> handle_error
operation |> is_not_error |> continue_processing
```

## 9. 実行モデル

uncodeはインタプリタ型の言語で、以下の手順で実行されます：

1. レキサー（字句解析器）がソースコードをトークン列に変換
2. パーサー（構文解析器）がトークン列を抽象構文木（AST）に変換
3. インタプリタがASTを評価して実行

## 10. 制限事項

- 現在のバージョンでは、並列処理や非同期処理はサポートされていません
- 大規模なアプリケーション開発には適していません
- パフォーマンスは最適化されていないため、計算量の多い処理には不向きです

## 11. 将来の拡張予定

- モジュールシステムの導入
- 例外処理の強化
- 並列処理のサポート
- パフォーマンスの最適化
